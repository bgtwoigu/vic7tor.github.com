---
layout: post
title: "u boot spl"
description: ""
category: 
tags: []
---
{% include JB/setup %}
#0. include/configs/mini2440.h 与 include/autoconf.mk
autoconf.mk被Makefile所包含(Makefile中有些使用的宏就来自一些头文件中)，autoconf.mk是由一个autoconf.mk.dep文件生成的，这个文件中列出了很多头文件。包括include/configs/mini2440.h。
这就是`u-boot`的一个特别的地方。

#1. spl/Makefile
u-boot-spl是由哪些文件编译成的就在这个文件中了。

#2. spl加载主u-boot
当是spl构建时会有CONFIG_SPL_BUILD定义，这个要自己处理好在哪里载入u-boot。
我的一个做法是在board_init_r中，因为这个在CONFIG_SPL_BUILD没有被定义。

    void board_init_r(gd_t *id, ulong dest_addr)
    {
        nand_init();
        nand_boot(); 
    }

nand_init与nand_boot都是`drivers/mtd/nand/nand_spl_simple.c`中定义的。
这个文件要被编译的话，要编译三个宏。CONFIG_CMD_NAND、CONFIG_SPL_BUILD、CONFIG_SPL_NAND_SIMPLE。

##1.nand_init
1.nand_chip.IO_ADDR_R = nand_chip.IO_ADDR_W = `(void  __iomem *)CONFIG_SYS_NAND_BASE;`
2.board_nand_init
成功这个函数要返回0

对于nand_spl_simple.c中实现的nand_init与nand.c中实现的不一样。后者与内核中的一样，设置了`chip->write_buf`等函数。在nand.c中是在nand_init中调用nand_init_chip再调用nand_scan。

在board_nand_init中，要么SPL与一般的分开来，要么都弄成同一个。如果前面设置了，nand_scan_ident是不会设置的。

先初始化硬件

在board_nand_init中要设置的函数
read_buf
ecc.mode - NAND_ECC_HW NAND_ECC_SOFT 
cmd_ctrl - 见nand_command的实现
dev_ready
chip_delay
ecc.hwctl - 非SOFT ECC设置
options NAND_BUSWIDTH_16

3.在nand_read_page中使用了

	ecc_calc = (u_char *)(CONFIG_SYS_SDRAM_BASE + 0x10000);

要小心点。。

4.在nand_spl_simple.c中使用到的宏
下面这些仅在nand_spl_simple.c中使用，因为nand_scan_ident与nand_scan_tail会设置

	CONFIG_SYS_NAND_PAGE_COUNT
	CONFIG_SYS_NAND_4_ADDR_CYCLE CONFIG_SYS_NAND_5_ADDR_CYCLE
	CONFIG_SYS_NAND_BAD_BLOCK_POS
	CONFIG_SYS_NAND_OOBSIZE
	CONFIG_SYS_NAND_BLOCK_SIZE
	CONFIG_SYS_NAND_ECCSTEPS
	CONFIG_SYS_NAND_ECCTOTAL
	CONFIG_SYS_NAND_ECCSIZE
	CONFIG_SYS_NAND_ECCBYTES
	CONFIG_SYS_NAND_ECCPOS

下面几个都会用到：

	CONFIG_SYS_NAND_BASE - IO_ADDR_R　IO_ADDR_W
	CONFIG_SYS_MAX_NAND_DEVICE - 系统中有几个设备
	CONFIG_SYS_NAND_MAX_CHIPS - 有的一个设备中还能有多个chip..
