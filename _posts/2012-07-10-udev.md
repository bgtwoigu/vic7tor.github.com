---
layout: post
title: "udev"
description: ""
category: 
tags: []
---
{% include JB/setup %}
先挖个坑，改天来写。/etc/udev/udev.conf可以打开调试信息。研究下调用register_tty_device时udev会发生什么事情。
man udev会给出一些默认udev规则所在的位置。还有udevadm(在当前的archlinux中)这个程序。

#1.内核如何与udev通信
在device_create函数中，其调用的device_add函数会无条件调用一个叫kobject_uevent的函数(它调用kobject_uevent_env这个函数发送消息。kset.uevent_ops在这个函数中被大量使用了。
下面这个程序可以接收内核发出的uevent。关于netlink，可以man 7 netlink。addr.nl_groups为1的原因是kobject_uevent_env调用netlink_broadcast_filtered时group参数为1。

    #include <stdio.h>
    #include <string.h>
    #include <unistd.h>
    #include <sys/socket.h>
    #include <linux/netlink.h>
    
    #define UEVENT_BUFFER_SIZE 1024
    
    static int init_uevent_sock(void)
    {
    	int uevent_sock;
    	int ret;
    	struct sockaddr_nl addr;
    	memset(&addr, 0x0, sizeof(struct sockaddr_nl));
    	addr.nl_family= AF_NETLINK;
    	addr.nl_pid = getpid();
    	addr.nl_groups = 1;
    	uevent_sock = socket(PF_NETLINK, SOCK_DGRAM,
    	NETLINK_KOBJECT_UEVENT);
    	if (uevent_sock < 0)
    		return -1;
    	ret = bind(uevent_sock, (struct sockaddr *)&addr,
    		sizeof(struct sockaddr_nl));
    	if (ret < 0) {
    		close(uevent_sock);
    		return -1;
    	}
    	return uevent_sock;
    }
    
    int main()
    {
    	char buf[UEVENT_BUFFER_SIZE];
    	int uevent_sock = init_uevent_sock();
    	
    	if (uevent_sock < 0)
    		return uevent_sock;
    
    	while(1) {
    		recv(uevent_sock, buf, sizeof(buf), 0);
    		printf("uevent:%s\n", buf);
    	}
    	return 0;
    }

#2.kobject_uevent_env
下面条件该函数会返回，不会广播消息:
1.kobject的祖先没有kset，因为后面要使用kset的uevent_ops
2.kobject的uevent_suppress为1
3.uevent_ops.filter为NULL或者被uevent_ops.filter过滤掉
4.没有subsystem
